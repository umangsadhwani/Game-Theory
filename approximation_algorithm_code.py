# -*- coding: utf-8 -*-
"""Approximation Algorithm Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LZpoRbkfZUAPbsbx6-C4hmSaJe1Yj93s
"""

import numpy as np

def allocate_goods(valuations):
    """Allocate goods to maximize total valuation."""
    global total_valuations
    n_agents, n_goods = valuations.shape
    allocation = np.zeros((n_agents, n_goods), dtype=bool)
    total_valuations = np.zeros(n_agents)
    for good in range(n_goods):
        buyer = np.argmax(valuations[:, good])
        allocation[buyer, good] = True
        total_valuations[buyer] += valuations[buyer, good]
    return allocation

def attempt_ef1_adjustment(valuations):
    """Attempt to adjust allocations to be EF1, without guaranteeing Pareto efficiency."""
    n_agents, n_goods = valuations.shape
    for agent in range(n_agents):
        for other_agent in range(n_agents):
            if agent == other_agent:
                continue
            # Check if removing any good from other_agent's allocation would satisfy EF1 for agent
            for good in range(n_goods):
                if allocation[other_agent, good]:
                    # Temporarily transfer good to see if EF1 is satisfied
                    allocation[agent, good] = True
                    allocation[other_agent, good] = False
                    if np.sum(valuations[agent, :] * allocation[agent, :]) >= np.sum(valuations[agent, :] * allocation[other_agent, :]):
                        # EF1 satisfied, keep the transfer
                        return True
                    else:
                        # Revert the transfer, not EF1
                        allocation[agent, good] = False
                        allocation[other_agent, good] = True
    return False

def check_and_improve_pareto(valuations):
    """Check for Pareto improvements through single good exchanges between agents and apply them. This is a simplified approach."""
    n_agents, n_goods = valuations.shape
    improved = True
    while improved:
        improved = False
        for agent in range(n_agents):
            for other_agent in range(agent + 1, n_agents):
                for good in range(n_goods):
                    # Check if swapping the good improves utility for at least one agent without decreasing it for the other
                    if allocation[agent, good] and not allocation[other_agent, good]:
                        # Calculate utility change if good was swapped
                        current_utility_agent = np.sum(valuations[agent] * allocation[agent])
                        current_utility_other_agent = np.sum(valuations[other_agent] * allocation[other_agent])
                        # Swap good
                        allocation[agent, good] = False
                        allocation[other_agent, good] = True
                        new_utility_agent = np.sum(valuations[agent] * allocation[agent])
                        new_utility_other_agent = np.sum(valuations[other_agent] * allocation[other_agent])
                        # Check for Pareto improvement
                        if new_utility_agent >= current_utility_agent and new_utility_other_agent > current_utility_other_agent:
                            improved = True  # Pareto improvement found
                        elif new_utility_agent > current_utility_agent and new_utility_other_agent >= current_utility_other_agent:
                            improved = True  # Pareto improvement found
                        else:
                            # Swap back if no improvement
                            allocation[agent, good] = True
                            allocation[other_agent, good] = False
    return allocation

def print_allocation_results(valuations, allocation):
    """Print the allocation and total valuations."""
    print("Final Allocation Matrix:\n", allocation.astype(int))
    print("Total Valuation by Agent:", np.sum(valuations * allocation, axis=1))

# Sample valuations for agents and goods (rows: agents, columns: goods)
valuations = np.array([
    [10, 20, 30, 40],  # Agent 1's valuations
    [40, 30, 20, 10],  # Agent 2's valuations
    [25, 25, 25, 25],  # Agent 3's valuations
])

# Test cases
allocation = allocate_goods(valuations)
ef1_adjusted = attempt_ef1_adjustment(valuations)
pareto_allocation = check_and_improve_pareto(valuations)
print_allocation_results(valuations, pareto_allocation)