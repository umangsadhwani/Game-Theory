# -*- coding: utf-8 -*-
"""Moving knife.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ye6E2hwF5_Cqi4L2k24BZe6RR2-PhcmA
"""

def allocate_sub_interval(ell, r, N_prime, utility_functions):
    """
    Recursively allocates a mixed cake [ell, r] to a set of agents N' based on utility functions.
    """
    # Step 1: Initialize allocations
    pi_hat = {i: [] for i in N_prime}

    # Step 2: Set of agents with positive utility for [ell, r]
    N_plus = {i for i in N_prime if utility_functions[i]((ell, r)) > 0}

    if N_plus:  # Step 3: If there are agents with positive utility
        if len(N_plus) == 1:  # Step 4: If only one agent values [ell, r] positively
            agent = next(iter(N_plus))
            pi_hat[agent] = [(ell, r)]  # Step 5: Allocate entire interval to the agent
        else:  # Step 6: More than one agent values it positively
            # Find division point for each agent
            x = {i: find_division_point(ell, r, utility_functions[i], len(N_plus)) for i in N_plus}
            # Find agent with minimum division point
            j = min(x, key=x.get)
            # Recursively allocate [ell, x[j]] to other agents
            pi_hat.update(allocate_sub_interval(ell, x[j], N_prime - {j}, utility_functions))
            pi_hat[j] = [(x[j], r)]
    else:  # Step 10: No agent values the interval positively
        # Similar steps for agents with non-positive utility
        x = {i: find_division_point_neg(ell, r, utility_functions[i], len(N_prime)) for i in N_prime}
        j = max(x, key=x.get)
        pi_hat.update(allocate_sub_interval(x[j], r, N_prime - {j}, utility_functions))
        pi_hat[j] = [(ell, x[j])]

    return pi_hat

# Placeholder functions for 'find_division_point' and 'find_division_point_neg'
# These should be defined to determine where to divide the cake for each agent
def find_division_point(ell, r, utility_function, n):
    # This is a mock implementation, the actual implementation should be based on the utility function
    return ell + (r - ell) / n

def find_division_point_neg(ell, r, utility_function, n):
    # This is a mock implementation, the actual implementation should be based on the utility function
    return ell + (r - ell) / n

# Test cases
# Define utility functions for each agent
def utility_function_agent_1(interval):
    return interval[1] - interval[0]  # Example utility function

def utility_function_agent_2(interval):
    return (interval[1] ** 2 - interval[0] ** 2) / 2  # Example utility function

utility_functions = {
    1: utility_function_agent_1,
    2: utility_function_agent_2
}

# Run the algorithm
agents = {1, 2}
allocation = allocate_sub_interval(0, 10, agents, utility_functions)
print(allocation)